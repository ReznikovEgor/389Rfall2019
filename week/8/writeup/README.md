# Writeup 8 - Binaries II

Name: Egor Reznikov
Section: 0101

I pledge on my honor that I have not given or received any unauthorized assistance on this assignment or examination.

Digital acknowledgement: Egor Reznikov

## Assignment Writeup

### Part 1 (100 pts)
Answer the following questions regarding the server executable (for which source is provided).

1. How is the per-session administrator password generated? Are there any inherent weaknesses in this implementation?
    The passwords are generated by using the current the time, srand(time(0)), of size 16 with random ascii values in hex. It was quite simple to replicate so that you can gain admin permissions.

2. Describe two vulnerabilities in this program. Provide specific line numbers and classifications of the vulnerability. Explain potential ramifications as well as ways to avoid these vulnerabilities when writing code.
    Line 46 There was a vulnerability in cipher, "printf(output)", which allows users to use a format strings vulnerabilities. You can use "%x", which would be "%k" due to ROT-13. This can be avoided by add %s and not using a literal variable only. \nLine 68 The other vulnerability was in exec_command, gets(buff). This allowed attackers to use a buffer overflow to change the stack. If you use fgets as apposed to gets, this can be avoided.

3. What is the flag?
CMSC389R-{expl017-2-w1n}

4. Describe the process you followed to obtain the flag: vulnerabilities exploited, your inputs to the server in a human-readable format, etc. If you create any helper code please include it.

To break the password, I attempted to find it using the format string vulnerability but was unable to figure it out. I choose to create a new c program that replicated the password creation and used a python script to use the output of the c program at the same time I connected to the server. This worked and I had admin privileges. \n
Once I have this, I used ls to see what was in execute command and found that there was a flag file. cat flag didn't work so I look at the exec_command and saw that there was a buffer that was size 33. I input 'cat flag' + ' ' * 25 since cat flag is 8 long and I still needed 25 more bits, and this output "Unable to locate cat flag                         in {}" so I added this again since the FLAG_SIZE was the same size and I was given the flag. I needed 2 cat flag calls since in exec_commands at line 71 there is a comparison to make sure that buff is in commands, and it would then execute cat flag.