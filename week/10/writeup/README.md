# Writeup 10 - Crypto I

Name: Egor Reznikov
Section: 0101

I pledge on my honor that I have not given or received any unauthorized assistance on this assignment or examination.

Digital acknowledgement: Egor Reznikov


## Assignment details

### Part 1 (45 Pts)
1. What is the structure of the ledger file format? Include exact byte offsets when static.

    16 bytes are used for key hash, 16 bytes are used for ctext hash, 16 bytes are used for IV, and the rest of the bytes are for the ctext.

2. What specific cryptographic implementations are used by the program? I.e. not "hashing", but a specific algorithm. Why might this pose a risk?

    They use AES128 encryption for the cipher text, and then hashed using MD5. The key and the key_hash are also hashed using MD5. MD5 is prone to hash collision weakness. MD5 was deemed "cryptographically broken" in 2010. There are better encryptions than AES128 currently

3. What information, if any, are you able to derive from ledger.bin without decrypting it at all?

    We know that the first 48 bytes are used for the for the key hash, ctext hash, and the IV. The rest of the bytes are used for the ctext and if you look at the file on github, you can see that the bin file is 656 bytes so we can find the length of the ctext. 656 - 48 = 608.

4. How does the application ensure Confidentiality? How is the encryption key derived?

    The application uses AES128 to insure the data's confidentiality. The encryption key is generated by using the command-line argument (password), using MD5 on it and then zeroing all the bytes except for the first two bytes and using MD5 again.

5. How does the application ensure Integrity? Is this flawed in any way?

    The integrity is ensured by comparing the ciphertext hash and the hash in the ledger are the same. This is flawed due to the hash being stored in the ledger, which means that if you can access the ledger, you can change the hash that is hashed to match any ciphertext hash.

6. How does the application ensure Authenticity? Is this flawed in any way?

    The application ensures authentication by comparing the password the user puts in and compares the key_hash in the file to make sure that they are the same. The key can be brute forced using the method we use in Part 2.

7. How is the initialization vector generated and subsequently stored? Are there any issues with this implementation?

    The initialization vector is generated using 16 random bytes and is stored in the ledger. Due to it being random, it shouldn't have any issues.

### Part 2 (45 Pts)
My program does a brute force to find the password. In ledger.c, key_hash is 16 bytes. I attempted to look for a 4 character password and then hashed in the same way as Wattsamp does in ledger.c. I used the password that was returned from my crack.c and it let me into the ledger.


The flag is 
>CMSC389R-{k3y5p4c3_2_sm411}

### Part 3 (10 Pts)

I believe that obfuscation should be encouraged to stop malicious attackers from breaking a companies encryption, due to how we were able to break the encryption in this project. If we follow Kerckhoffs's principle and allow anyone to see the code and attempt to keep everything secure except for the key, it can lead to people studying and attempt to break someone's code, since you can't always be sure that everything is secure. Having things hidden from the public eliminates the possibility for attacker to understand how your system works and attempt to break your encryption. If we can follow Kerckhoff's principle and have everything secure, that would be great, but there is no guarantee.